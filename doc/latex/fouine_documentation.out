\documentclass[11pt]{article} 
\usepackage[latin1]{inputenc} 
\usepackage[T1]{fontenc} 
\usepackage{textcomp}
\usepackage{fullpage} 
\usepackage{url} 
\usepackage{ocamldoc}
\begin{document}
\tableofcontents
\section{Module {\tt{Affichage}} : Ce module gère l'affichage des composantes du noyau de fouine}
\label{module:Affichage}\index{Affichage@\verb`Affichage`}




\ocamldocvspace{0.5cm}



\label{val:Affichage.string-underscoreof-underscoreidentifier}\begin{ocamldoccode}
val string_of_identifier : {\textquotesingle}a -> {\textquotesingle}a
\end{ocamldoccode}
\index{string-underscoreof-underscoreidentifier@\verb`string_of_identifier`}




\label{val:Affichage.string-underscoreof-underscoreexpr}\begin{ocamldoccode}
val string_of_expr : int -> Expr.extexpr -> Expr.name
\end{ocamldoccode}
\index{string-underscoreof-underscoreexpr@\verb`string_of_expr`}
\begin{ocamldocdescription}
string\_of\_expr prend en entrée une expression et retourne  un code executable en Caml


\end{ocamldocdescription}




\label{val:Affichage.aff-underscorebexpr}\begin{ocamldoccode}
val aff_bexpr : int -> Expr.bextexpr -> Expr.name
\end{ocamldoccode}
\index{aff-underscorebexpr@\verb`aff_bexpr`}




\label{val:Affichage.string-underscoreof-underscoreexpr-underscorebin}\begin{ocamldoccode}
val string_of_expr_bin :
  int -> string -> Expr.extexpr -> Expr.extexpr -> Expr.name
\end{ocamldoccode}
\index{string-underscoreof-underscoreexpr-underscorebin@\verb`string_of_expr_bin`}




\label{val:Affichage.istring-underscoreof-underscoreexpr}\begin{ocamldoccode}
val istring_of_expr : Expr.extexpr -> string
\end{ocamldoccode}
\index{istring-underscoreof-underscoreexpr@\verb`istring_of_expr`}
\begin{ocamldocdescription}
Convertit un arbre de syntaxe en une chaîne de caractère de code caml


\end{ocamldocdescription}




\label{val:Affichage.istring-underscoreof-underscorebexpr}\begin{ocamldoccode}
val istring_of_bexpr : Expr.bextexpr -> string
\end{ocamldoccode}
\index{istring-underscoreof-underscorebexpr@\verb`istring_of_bexpr`}




\label{val:Affichage.istring-underscoreaux}\begin{ocamldoccode}
val istring_aux : string -> Expr.extexpr -> Expr.extexpr -> string
\end{ocamldoccode}
\index{istring-underscoreaux@\verb`istring_aux`}




\label{val:Affichage.string-underscoreof-underscorevalue}\begin{ocamldoccode}
val string_of_value : Env.value -> string
\end{ocamldoccode}
\index{string-underscoreof-underscorevalue@\verb`string_of_value`}
\begin{ocamldocdescription}
Convertit une valeur interne en texte lisible


\end{ocamldocdescription}




\label{val:Affichage.print-underscorevalue}\begin{ocamldoccode}
val print_value : Env.value -> unit
\end{ocamldoccode}
\index{print-underscorevalue@\verb`print_value`}
\begin{ocamldocdescription}
Affiche une valeur interne


\end{ocamldocdescription}




\label{val:Affichage.penv-underscoreitem}\begin{ocamldoccode}
val penv_item : string -> Env.value -> unit
\end{ocamldoccode}
\index{penv-underscoreitem@\verb`penv_item`}




\label{val:Affichage.print-underscoreenv}\begin{ocamldoccode}
val print_env : Env.value Env.Environnement.t -> unit
\end{ocamldoccode}
\index{print-underscoreenv@\verb`print_env`}




\label{val:Affichage.debug}\begin{ocamldoccode}
val debug : {\textquotesingle}a -> Env.value Env.Environnement.t -> unit
\end{ocamldoccode}
\index{debug@\verb`debug`}
\begin{ocamldocdescription}
Cette fonction générique est appelée au début de la fonction d'évaluation,
elle permet de rendre modulaire l'affichage du débug


\end{ocamldocdescription}




\label{val:Affichage.aff-underscoreexpr}\begin{ocamldoccode}
val aff_expr : Expr.extexpr -> unit
\end{ocamldoccode}
\index{aff-underscoreexpr@\verb`aff_expr`}


\section{Module {\tt{Arguments}} : Gère l'ensemble des arguments pouvant être passés en ligne de commande à fouine}
\label{module:Arguments}\index{Arguments@\verb`Arguments`}




\ocamldocvspace{0.5cm}



Modes de débuggages



\label{val:Arguments.debugmode}\begin{ocamldoccode}
val debugmode : bool Pervasives.ref
\end{ocamldoccode}
\index{debugmode@\verb`debugmode`}




\label{val:Arguments.verbosemode}\begin{ocamldoccode}
val verbosemode : bool Pervasives.ref
\end{ocamldoccode}
\index{verbosemode@\verb`verbosemode`}




\label{val:Arguments.mem-underscoremode}\begin{ocamldoccode}
val mem_mode : bool Pervasives.ref
\end{ocamldoccode}
\index{mem-underscoremode@\verb`mem_mode`}




\label{val:Arguments.tradimp}\begin{ocamldoccode}
val tradimp : bool Pervasives.ref
\end{ocamldoccode}
\index{tradimp@\verb`tradimp`}
\begin{ocamldocdescription}
Modes de traduction


\end{ocamldocdescription}




\label{val:Arguments.tradexcep}\begin{ocamldoccode}
val tradexcep : bool Pervasives.ref
\end{ocamldoccode}
\index{tradexcep@\verb`tradexcep`}




\label{val:Arguments.impexcep}\begin{ocamldoccode}
val impexcep : bool Pervasives.ref
\end{ocamldoccode}
\index{impexcep@\verb`impexcep`}




\label{val:Arguments.excepimp}\begin{ocamldoccode}
val excepimp : bool Pervasives.ref
\end{ocamldoccode}
\index{excepimp@\verb`excepimp`}




\label{val:Arguments.outcode}\begin{ocamldoccode}
val outcode : bool Pervasives.ref
\end{ocamldoccode}
\index{outcode@\verb`outcode`}




\label{val:Arguments.stackcode}\begin{ocamldoccode}
val stackcode : bool Pervasives.ref
\end{ocamldoccode}
\index{stackcode@\verb`stackcode`}
\begin{ocamldocdescription}
pour la compilation


\end{ocamldocdescription}




\label{val:Arguments.machine}\begin{ocamldoccode}
val machine : bool Pervasives.ref
\end{ocamldoccode}
\index{machine@\verb`machine`}




typechecking



\label{val:Arguments.typecheckingmode}\begin{ocamldoccode}
val typecheckingmode : bool Pervasives.ref
\end{ocamldoccode}
\index{typecheckingmode@\verb`typecheckingmode`}




\label{val:Arguments.displaytype}\begin{ocamldoccode}
val displaytype : bool Pervasives.ref
\end{ocamldoccode}
\index{displaytype@\verb`displaytype`}




\label{val:Arguments.mem-underscorefile}\begin{ocamldoccode}
val mem_file : string Pervasives.ref
\end{ocamldoccode}
\index{mem-underscorefile@\verb`mem_file`}
\begin{ocamldocdescription}
Fichier contenant les fonctions de mémoire


\end{ocamldocdescription}




\label{val:Arguments.srcfile}\begin{ocamldoccode}
val srcfile : string Pervasives.ref
\end{ocamldoccode}
\index{srcfile@\verb`srcfile`}




\label{val:Arguments.read-underscoreall}\begin{ocamldoccode}
val read_all : Pervasives.in_channel -> string
\end{ocamldoccode}
\index{read-underscoreall@\verb`read_all`}
\begin{ocamldocdescription}
Lit un in\_channel entier jusqu'à tomber sur End\_of\_file


\end{ocamldocdescription}




Lit spécifiquement un fichier



\label{val:Arguments.read-underscorefile}\begin{ocamldoccode}
val read_file : string -> string
\end{ocamldoccode}
\index{read-underscorefile@\verb`read_file`}




\label{val:Arguments.getsrcfile}\begin{ocamldoccode}
val getsrcfile : string -> unit
\end{ocamldoccode}
\index{getsrcfile@\verb`getsrcfile`}
\begin{ocamldocdescription}
Lit le fichier source passé en argument anonyme et le copie sous forme de string dans srcfile


\end{ocamldocdescription}




\label{val:Arguments.set-underscoremem}\begin{ocamldoccode}
val set_mem : string -> unit
\end{ocamldoccode}
\index{set-underscoremem@\verb`set_mem`}




\label{val:Arguments.optlist}\begin{ocamldoccode}
val optlist : (string * Arg.spec * string) list
\end{ocamldoccode}
\index{optlist@\verb`optlist`}
\begin{ocamldocdescription}
Ensemble des arguments possibles


\end{ocamldocdescription}




\label{val:Arguments.usage}\begin{ocamldoccode}
val usage : string
\end{ocamldoccode}
\index{usage@\verb`usage`}
\begin{ocamldocdescription}
Message de doc


\end{ocamldocdescription}


\section{Module {\tt{Composantmachine}} : Ce module définit les composantes nécessaires à l'implémentation de la machine à pile}
\label{module:Composantmachine}\index{Composantmachine@\verb`Composantmachine`}




\ocamldocvspace{0.5cm}



\label{exception:Composantmachine.Notmatched}\begin{ocamldoccode}
exception Notmatched
\end{ocamldoccode}
\index{Notmatched@\verb`Notmatched`}




\label{type:Composantmachine.name}\begin{ocamldoccode}
type name = string 
\end{ocamldoccode}
\index{name@\verb`name`}




\label{type:Composantmachine.instruction}\begin{ocamldoccode}
type instruction =
  | C of int
  | Add
  | Mul
  | Sub
  | Div
  | Let of name
  | Access of name
  | Endlet
  | Clos of name * instruction list
  | Rec of name
  | Ret
  | Apply
  | IfThenElse of instruction list * instruction list
  | Eq
  | Neq
  | Lt
  | Gt
  | Le
  | Ge
  | Print
  | Ref
  | Aff
  | Bang
  | Raise
  | Beginwith
  | Endwith
  | Endexcep
  | Ajoutcouple
  | Acoupler of instruction list list
  | Couple of instruction list list
\end{ocamldoccode}
\index{instruction@\verb`instruction`}
\begin{ocamldocdescription}
Notre langage de la machine à pile


\end{ocamldocdescription}




\label{type:Composantmachine.code}\begin{ocamldoccode}
type code = instruction list 
\end{ocamldoccode}
\index{code@\verb`code`}
\begin{ocamldocdescription}
Un programme pour la machine à pile est une liste d'instructions


\end{ocamldocdescription}




\label{type:Composantmachine.memslot}\begin{ocamldoccode}
type memslot =
  | I of int
  | B of bool
  | Clot of (name * instruction list *
 environnement)
  | ClotR of (name * name *
 instruction list * environnement)
  | Lcode of instruction list
  | Lenv of environnement
  | Eps
  | Reference of int
  | Exception
  | Ignore
  | Uplet of memslot list
  | Amatcher of memslot list
  | Valcouple of memslot
\end{ocamldoccode}
\index{memslot@\verb`memslot`}
\begin{ocamldocdescription}
Représente une case mémoire de notre machine à pile


\end{ocamldocdescription}




\label{type:Composantmachine.environnement}\begin{ocamldoccode}
type environnement = (name * memslot) list 
\end{ocamldoccode}
\index{environnement@\verb`environnement`}
\begin{ocamldocdescription}
La pile est un ensemble de cases mémoire


\end{ocamldocdescription}




\label{type:Composantmachine.pile}\begin{ocamldoccode}
type pile = memslot list 
\end{ocamldoccode}
\index{pile@\verb`pile`}


\section{Module {\tt{Constructeur}} : Définit l'ensemble des méta constructeurs utiles pour écrire proprement les transformations de programme}
\label{module:Constructeur}\index{Constructeur@\verb`Constructeur`}




\ocamldocvspace{0.5cm}



\label{val:Constructeur.mkApp}\begin{ocamldoccode}
val mkApp : Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkApp@\verb`mkApp`}




\label{val:Constructeur.mkAppxy}\begin{ocamldoccode}
val mkAppxy : Expr.extexpr -> Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkAppxy@\verb`mkAppxy`}




\label{val:Constructeur.mkAppxyz}\begin{ocamldoccode}
val mkAppxyz :
  Expr.extexpr ->
  Expr.extexpr -> Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkAppxyz@\verb`mkAppxyz`}




\label{val:Constructeur.mkFun}\begin{ocamldoccode}
val mkFun : Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkFun@\verb`mkFun`}




\label{val:Constructeur.mkFunxy}\begin{ocamldoccode}
val mkFunxy : Expr.extexpr -> Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkFunxy@\verb`mkFunxy`}




\label{val:Constructeur.mkLet}\begin{ocamldoccode}
val mkLet : Expr.extexpr -> Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkLet@\verb`mkLet`}




\label{val:Constructeur.mkLetPair}\begin{ocamldoccode}
val mkLetPair :
  Expr.extexpr * Expr.extexpr ->
  Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkLetPair@\verb`mkLetPair`}




\label{val:Constructeur.mkLetRec}\begin{ocamldoccode}
val mkLetRec :
  Expr.extexpr -> Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkLetRec@\verb`mkLetRec`}




\label{val:Constructeur.mkIdentifier}\begin{ocamldoccode}
val mkIdentifier : Expr.name -> int * Expr.expr
\end{ocamldoccode}
\index{mkIdentifier@\verb`mkIdentifier`}




\label{val:Constructeur.mkPair}\begin{ocamldoccode}
val mkPair : Expr.extexpr * Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkPair@\verb`mkPair`}




\label{val:Constructeur.mkAdd}\begin{ocamldoccode}
val mkAdd : Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkAdd@\verb`mkAdd`}




\label{val:Constructeur.mkMul}\begin{ocamldoccode}
val mkMul : Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkMul@\verb`mkMul`}




\label{val:Constructeur.mkDiv}\begin{ocamldoccode}
val mkDiv : Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkDiv@\verb`mkDiv`}




\label{val:Constructeur.mkSou}\begin{ocamldoccode}
val mkSou : Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkSou@\verb`mkSou`}




\label{val:Constructeur.mkConst}\begin{ocamldoccode}
val mkConst : int -> int * Expr.expr
\end{ocamldoccode}
\index{mkConst@\verb`mkConst`}




\label{val:Constructeur.mkCart}\begin{ocamldoccode}
val mkCart : Expr.extexpr list -> int * Expr.expr
\end{ocamldoccode}
\index{mkCart@\verb`mkCart`}




\label{val:Constructeur.mkConstr}\begin{ocamldoccode}
val mkConstr : Expr.name -> Expr.extexpr list -> int * Expr.expr
\end{ocamldoccode}
\index{mkConstr@\verb`mkConstr`}




\label{val:Constructeur.mkMatch}\begin{ocamldoccode}
val mkMatch : Expr.extexpr -> Expr.extexpr list -> int * Expr.expr
\end{ocamldoccode}
\index{mkMatch@\verb`mkMatch`}




\label{val:Constructeur.mkPattCase}\begin{ocamldoccode}
val mkPattCase : Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkPattCase@\verb`mkPattCase`}




\label{val:Constructeur.mkPrintInt}\begin{ocamldoccode}
val mkPrintInt : Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkPrintInt@\verb`mkPrintInt`}




\label{val:Constructeur.mkCond}\begin{ocamldoccode}
val mkCond : Expr.bextexpr -> Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkCond@\verb`mkCond`}




\label{val:Constructeur.mkBool}\begin{ocamldoccode}
val mkBool : Expr.expr -> Expr.extexpr -> Expr.extexpr -> int * Expr.bexpr
\end{ocamldoccode}
\index{mkBool@\verb`mkBool`}




\label{val:Constructeur.mkLVide}\begin{ocamldoccode}
val mkLVide : unit -> int * Expr.expr
\end{ocamldoccode}
\index{mkLVide@\verb`mkLVide`}




\label{val:Constructeur.mkListe}\begin{ocamldoccode}
val mkListe : Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkListe@\verb`mkListe`}




\label{val:Constructeur.mkUnit}\begin{ocamldoccode}
val mkUnit : unit -> int * Expr.expr
\end{ocamldoccode}
\index{mkUnit@\verb`mkUnit`}




\label{val:Constructeur.mkRef}\begin{ocamldoccode}
val mkRef : Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkRef@\verb`mkRef`}




\label{val:Constructeur.mkAcc}\begin{ocamldoccode}
val mkAcc : Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkAcc@\verb`mkAcc`}




\label{val:Constructeur.mkAff}\begin{ocamldoccode}
val mkAff : Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkAff@\verb`mkAff`}




\label{val:Constructeur.mkmodify}\begin{ocamldoccode}
val mkmodify :
  Expr.extexpr -> Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkmodify@\verb`mkmodify`}




\label{val:Constructeur.mkallocate}\begin{ocamldoccode}
val mkallocate : Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkallocate@\verb`mkallocate`}




\label{val:Constructeur.mkread}\begin{ocamldoccode}
val mkread : Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkread@\verb`mkread`}




\label{val:Constructeur.mkConstr}\begin{ocamldoccode}
val mkConstr : Expr.name -> Expr.extexpr list -> int * Expr.expr
\end{ocamldoccode}
\index{mkConstr@\verb`mkConstr`}




\label{val:Constructeur.mkPattCase}\begin{ocamldoccode}
val mkPattCase : Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkPattCase@\verb`mkPattCase`}




\label{val:Constructeur.mkTry}\begin{ocamldoccode}
val mkTry : Expr.extexpr -> Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkTry@\verb`mkTry`}




\label{val:Constructeur.mkExep}\begin{ocamldoccode}
val mkExep : Expr.extexpr list -> int * Expr.expr
\end{ocamldoccode}
\index{mkExep@\verb`mkExep`}




\label{val:Constructeur.mkRaise}\begin{ocamldoccode}
val mkRaise : Expr.extexpr -> Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{mkRaise@\verb`mkRaise`}


\section{Module {\tt{Display}} : Quelques fonctions utilitaires utiles tout au long du projet, sans être spécifiques à fouine}
\label{module:Display}\index{Display@\verb`Display`}




\ocamldocvspace{0.5cm}



\label{val:Display.ps}\begin{ocamldoccode}
val ps : string -> unit
\end{ocamldoccode}
\index{ps@\verb`ps`}




\label{val:Display.p-underscoredebug}\begin{ocamldoccode}
val p_debug : string -> unit
\end{ocamldoccode}
\index{p-underscoredebug@\verb`p_debug`}




\label{val:Display.p-underscoreverbose}\begin{ocamldoccode}
val p_verbose : string -> unit
\end{ocamldoccode}
\index{p-underscoreverbose@\verb`p_verbose`}




\label{val:Display.prInt}\begin{ocamldoccode}
val prInt : int -> int
\end{ocamldoccode}
\index{prInt@\verb`prInt`}




\label{val:Display.join}\begin{ocamldoccode}
val join : string -> string list -> string
\end{ocamldoccode}
\index{join@\verb`join`}




\label{val:Display.tab}\begin{ocamldoccode}
val tab : int -> string
\end{ocamldoccode}
\index{tab@\verb`tab`}


\section{Module {\tt{Env}} : Définit les type nécessaires à l'intrepeter fouine et au noyau de fouine}
\label{module:Env}\index{Env@\verb`Env`}




\ocamldocvspace{0.5cm}



\begin{ocamldoccode}
{\tt{module }}{\tt{Environnement}}{\tt{ : }}\end{ocamldoccode}
\label{module:Env.Environnement}\index{Environnement@\verb`Environnement`}

{\tt{Map.Make}}{\tt{(}}{\tt{String}}{\tt{)}}





\label{type:Env.value}\begin{ocamldoccode}
type value =
  | Int of int
  | Unit
  | Reference of int
  | Fonction of Expr.extexpr * Expr.extexpr * env
  | Rec of Expr.name * Expr.extexpr * Expr.extexpr * env
\end{ocamldoccode}
\begin{ocamldoccomment}
le premier name garde le nom de la fonction


\end{ocamldoccomment}
\begin{ocamldoccode}
  | TSum of Expr.name * value list
\end{ocamldoccode}
\begin{ocamldoccomment}
Les types sommes


\end{ocamldoccomment}
\begin{ocamldoccode}
  | Cartesian of value list
\end{ocamldoccode}
\begin{ocamldoccomment}
les n-uplets


\end{ocamldoccomment}
\begin{ocamldoccode}
  | Listing of value * value
\end{ocamldoccode}
\begin{ocamldoccomment}
les listes


\end{ocamldoccomment}
\begin{ocamldoccode}
  | LVide
  | Exn of value
\end{ocamldoccode}
\begin{ocamldoccomment}
Constructeur spécial pour gérer les exceptions


\end{ocamldoccomment}
\begin{ocamldoccode}
  | Bool of bool
\end{ocamldoccode}
\index{value@\verb`value`}
\begin{ocamldocdescription}
Définit le type des valeurs internes à l'interpreter


\end{ocamldocdescription}




\label{type:Env.env}\begin{ocamldoccode}
type env = value Environnement.t 
\end{ocamldoccode}
\index{env@\verb`env`}
\begin{ocamldocdescription}
ces environnements contiennent des value


\end{ocamldocdescription}


\section{Module {\tt{Errmgr}} : Gère le rattrapage des erreurs de fouine}
\label{module:Errmgr}\index{Errmgr@\verb`Errmgr`}




\ocamldocvspace{0.5cm}



\begin{ocamldoccode}
{\tt{module }}{\tt{IntHash}}{\tt{ : }}\end{ocamldoccode}
\label{module:Errmgr.IntHash}\index{IntHash@\verb`IntHash`}

\begin{ocamldocsigend}


\label{type:Errmgr.IntHash.t}\begin{ocamldoccode}
type t = int 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{val:Errmgr.IntHash.equal}\begin{ocamldoccode}
val equal : {\textquotesingle}a -> {\textquotesingle}a -> bool
\end{ocamldoccode}
\index{equal@\verb`equal`}


\label{val:Errmgr.IntHash.hash}\begin{ocamldoccode}
val hash : int -> int
\end{ocamldoccode}
\index{hash@\verb`hash`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
Structure pour conserver les metadata des noeuds de l'ast


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{AstMetaData}}{\tt{ : }}\end{ocamldoccode}
\label{module:Errmgr.AstMetaData}\index{AstMetaData@\verb`AstMetaData`}

{\tt{Hashtbl.Make}}{\tt{(}}{\tt{IntHash}}{\tt{)}}





\label{val:Errmgr.metadata}\begin{ocamldoccode}
val metadata : (Lexing.position * Lexing.position) AstMetaData.t
\end{ocamldoccode}
\index{metadata@\verb`metadata`}




\label{val:Errmgr.pf}\begin{ocamldoccode}
val pf : ({\textquotesingle}a, Pervasives.out_channel, unit) Pervasives.format -> {\textquotesingle}a
\end{ocamldoccode}
\index{pf@\verb`pf`}
\begin{ocamldocdescription}
print format strings


\end{ocamldocdescription}




\label{exception:Errmgr.UnknownIdentifier}\begin{ocamldoccode}
exception UnknownIdentifier of string
\end{ocamldoccode}
\index{UnknownIdentifier@\verb`UnknownIdentifier`}
\begin{ocamldocdescription}
On définira ici l'ensemble des Exceptions que l'on souhaite gérer dans le parcours d'arbre


\end{ocamldocdescription}




\label{exception:Errmgr.UnknownReference}\begin{ocamldoccode}
exception UnknownReference of string
\end{ocamldoccode}
\index{UnknownReference@\verb`UnknownReference`}




\label{exception:Errmgr.NotReference}\begin{ocamldoccode}
exception NotReference of string
\end{ocamldoccode}
\index{NotReference@\verb`NotReference`}




\label{exception:Errmgr.DivisionByZero}\begin{ocamldoccode}
exception DivisionByZero
\end{ocamldoccode}
\index{DivisionByZero@\verb`DivisionByZero`}




\label{exception:Errmgr.CannotApply}\begin{ocamldoccode}
exception CannotApply of string
\end{ocamldoccode}
\index{CannotApply@\verb`CannotApply`}




\label{exception:Errmgr.NotFunction}\begin{ocamldoccode}
exception NotFunction of string
\end{ocamldoccode}
\index{NotFunction@\verb`NotFunction`}




\label{exception:Errmgr.BadArgument}\begin{ocamldoccode}
exception BadArgument of string * string
\end{ocamldoccode}
\index{BadArgument@\verb`BadArgument`}




\label{exception:Errmgr.UnificationFails}\begin{ocamldoccode}
exception UnificationFails of string * string
\end{ocamldoccode}
\index{UnificationFails@\verb`UnificationFails`}




\label{exception:Errmgr.FindingIdentifierFailed}\begin{ocamldoccode}
exception FindingIdentifierFailed
\end{ocamldoccode}
\index{FindingIdentifierFailed@\verb`FindingIdentifierFailed`}




\label{exception:Errmgr.PatternMatchingFails}\begin{ocamldoccode}
exception PatternMatchingFails of string
\end{ocamldoccode}
\index{PatternMatchingFails@\verb`PatternMatchingFails`}




\label{exception:Errmgr.Fail}\begin{ocamldoccode}
exception Fail
\end{ocamldoccode}
\index{Fail@\verb`Fail`}




Type related errors



\label{exception:Errmgr.TypesDoNotMatch}\begin{ocamldoccode}
exception TypesDoNotMatch of string * string
\end{ocamldoccode}
\index{TypesDoNotMatch@\verb`TypesDoNotMatch`}




\label{val:Errmgr.error-underscorehandler}\begin{ocamldoccode}
val error_handler : unit -> int
\end{ocamldoccode}
\index{error-underscorehandler@\verb`error_handler`}
\begin{ocamldocdescription}
Cette fonction est appelée à la création de chaque noeud de l'AST elle renvoie un entier qui permet de récupérer les metadata associées au noeud dans la table de hash et ajoute dans ladite table
les infos que l'on souhaite conserver, pour l'instant on garde uniquement les informations de position du début de l'erreur et de la fin: Voir Lexing.position


\end{ocamldocdescription}




\label{val:Errmgr.getdata}\begin{ocamldoccode}
val getdata : AstMetaData.key -> Lexing.position * Lexing.position
\end{ocamldoccode}
\index{getdata@\verb`getdata`}
\begin{ocamldocdescription}
Récupère les données liées à la position du noeud dans le code originel


\end{ocamldocdescription}




\label{val:Errmgr.getcolumn}\begin{ocamldoccode}
val getcolumn : Lexing.position -> int
\end{ocamldoccode}
\index{getcolumn@\verb`getcolumn`}
\begin{ocamldocdescription}
Calcule la colonne dans le fichier source


\end{ocamldocdescription}




\label{val:Errmgr.error-underscoredisplay}\begin{ocamldoccode}
val error_display : AstMetaData.key -> exn -> {\textquotesingle}a
\end{ocamldoccode}
\index{error-underscoredisplay@\verb`error_display`}
\begin{ocamldocdescription}
Cette fonction est appelée automatiquement dès qu'une erreur se produit dans le parcours de l'AST, elle prend en paramètre l'exception levée, il suffit de la modifier pour changer le comportement,
l'affichage des erreurs


\end{ocamldocdescription}


\section{Module {\tt{Eval}} : L'interpreter fouine et sa fonction eval}
\label{module:Eval}\index{Eval@\verb`Eval`}




\ocamldocvspace{0.5cm}



\label{val:Eval.toplevel-underscoreenvir}\begin{ocamldoccode}
val toplevel_envir : Env.value Env.Environnement.t Pervasives.ref
\end{ocamldoccode}
\index{toplevel-underscoreenvir@\verb`toplevel_envir`}




\label{val:Eval.buildEnv}\begin{ocamldoccode}
val buildEnv :
  Expr.extexpr ->
  {\textquotesingle}a Env.Environnement.t -> Expr.extexpr -> {\textquotesingle}a Env.Environnement.t
\end{ocamldoccode}
\index{buildEnv@\verb`buildEnv`}
\begin{ocamldocdescription}
Consruit l'environnement nécessaire à une fonction en n'ajoutant que les variables du corps de la fonction qui ne sont pas
des arguments à la cloture


\end{ocamldocdescription}




\label{val:Eval.unification}\begin{ocamldoccode}
val unification :
  Expr.extexpr ->
  Env.value -> Env.value Env.Environnement.t -> Env.value Env.Environnement.t
\end{ocamldoccode}
\index{unification@\verb`unification`}
\begin{ocamldocdescription}
Tente d'unifier une expression et une valeur dans le cadre d'un pattern matching


\end{ocamldocdescription}




\label{val:Eval.trymatch}\begin{ocamldoccode}
val trymatch :
  Env.value ->
  ({\textquotesingle}a * Expr.expr) list ->
  Env.value Env.Environnement.t -> Expr.extexpr * Env.value Env.Environnement.t
\end{ocamldoccode}
\index{trymatch@\verb`trymatch`}
\begin{ocamldocdescription}
renvoie l'expression qui correspond au premier matching qui convient, et l'environnement associé. En cas d'aucun matching possible, on lève à nouveau l'expression UnificationFails


\end{ocamldocdescription}




sémantique opérationnelle à grands pas



Pour gérer les exceptions, il y a les cas try$\ldots$with et raise à traier mais pas
seulement. Pour chaque autre cas si on effectue 2 eval typiquement:


let a $=$ eval $\ldots$ in eval bidule env$<$x/a$>$


Il faut exécuter le 1er eval, vérifier qu'il n'a pas levé d'exception et s'il
n'a rien levé on peut exécuter le second. Sinon on fait remonter l'exception.


C'est pour cette raison qu'il y a plein de nouveaux pattern matching dans le
code: ça évite les warning pour les trucs pas matchés


Il y a un nouveau type dans Value. Un type Exn of value (Exn c'est pour avoir
le même type d'exception que Ocaml) Ce ça qu'on renvoie quand on lève une
exception.



\label{val:Eval.eval}\begin{ocamldoccode}
val eval : Expr.extexpr -> Env.value Env.Environnement.t -> Env.value
\end{ocamldoccode}
\index{eval@\verb`eval`}




\label{val:Eval.evalb}\begin{ocamldoccode}
val evalb : Expr.bextexpr -> Env.value Env.Environnement.t -> Env.value
\end{ocamldoccode}
\index{evalb@\verb`evalb`}




\label{val:Eval.evallet}\begin{ocamldoccode}
val evallet :
  Expr.extexpr ->
  Expr.extexpr -> Expr.extexpr -> Env.value Env.Environnement.t -> Env.value
\end{ocamldoccode}
\index{evallet@\verb`evallet`}




\label{val:Eval.evalletrec}\begin{ocamldoccode}
val evalletrec :
  Expr.name ->
  Expr.extexpr -> Expr.extexpr -> Env.value Env.Environnement.t -> Env.value
\end{ocamldoccode}
\index{evalletrec@\verb`evalletrec`}




\label{val:Eval.evalapp}\begin{ocamldoccode}
val evalapp :
  Expr.extexpr -> Expr.extexpr -> Env.value Env.Environnement.t -> Env.value
\end{ocamldoccode}
\index{evalapp@\verb`evalapp`}


\section{Module {\tt{Expr}} : un type pour toutes les expressions qu'on manipule}
\label{module:Expr}\index{Expr@\verb`Expr`}




\ocamldocvspace{0.5cm}



\label{type:Expr.name}\begin{ocamldoccode}
type name = string 
\end{ocamldoccode}
\index{name@\verb`name`}




\begin{ocamldoccode}
{\tt{module }}{\tt{VarsSet}}{\tt{ : }}\end{ocamldoccode}
\label{module:Expr.VarsSet}\index{VarsSet@\verb`VarsSet`}

{\tt{Set.Make}}{\tt{(}}{\tt{String}}{\tt{)}}





\label{type:Expr.expr}\begin{ocamldoccode}
type expr =
  | Const of int
  | Add of extexpr * extexpr
  | Mul of extexpr * extexpr
  | Sou of extexpr * extexpr
  | Div of extexpr * extexpr
  | Let of (extexpr * extexpr) * extexpr
  | LetRec of (extexpr * extexpr) * extexpr
  | Identifier of name * extexpr
  | Fun of extexpr * extexpr
  | App of extexpr * extexpr
  | Cart of extexpr list
  | Constr of name * extexpr list
  | Match of extexpr * extexpr list
  | PattCase of extexpr * extexpr
  | Try of extexpr * extexpr list
  | Raise of extexpr
  | PrintInt of extexpr
  | Aff of extexpr * extexpr
  | Ref of extexpr
  | Acc of extexpr
  | Uni
  | Vide
  | Liste of extexpr * extexpr
  | Cond of bextexpr * extexpr * extexpr
  | Typed of extexpr
  | TypeId of name
  | RecordType of (name * extexpr list) * extexpr
  | Pure of extexpr
\end{ocamldoccode}
\index{expr@\verb`expr`}
\begin{ocamldocdescription}
Type des commandes fouines


\end{ocamldocdescription}




\label{type:Expr.bexpr}\begin{ocamldoccode}
type bexpr =
  | Testeq of extexpr * extexpr
  | Testneq of extexpr * extexpr
  | Testlt of extexpr * extexpr
  | Testgt of extexpr * extexpr
  | Testlet of extexpr * extexpr
  | Testget of extexpr * extexpr
\end{ocamldoccode}
\begin{ocamldoccomment}
Type de notre AST, il est étiqueté par des entiers pour pouvoir récupérer la position du noeud en cas d'erreur


\end{ocamldoccomment}
\index{bexpr@\verb`bexpr`}




\label{type:Expr.extexpr}\begin{ocamldoccode}
type extexpr = int * expr 
\end{ocamldoccode}
\index{extexpr@\verb`extexpr`}




\label{type:Expr.bextexpr}\begin{ocamldoccode}
type bextexpr = int * bexpr 
\end{ocamldoccode}
\index{bextexpr@\verb`bextexpr`}




\label{val:Expr.getIdentifiersInConstr}\begin{ocamldoccode}
val getIdentifiersInConstr : extexpr -> VarsSet.t
\end{ocamldoccode}
\index{getIdentifiersInConstr@\verb`getIdentifiersInConstr`}
\begin{ocamldocdescription}
Renvoie l'ensemble des variables présentes dans une expression servant de Pattern
cela permet de construire l'ensemble des variables libres dans le corps d'une fonction


\end{ocamldocdescription}




\label{val:Expr.freevars}\begin{ocamldoccode}
val freevars : VarsSet.t -> VarsSet.t -> extexpr -> VarsSet.t
\end{ocamldoccode}
\index{freevars@\verb`freevars`}
\begin{ocamldocdescription}
Renvoie les variables libres d'une expression  donc il faut modifier les tests bool�ens, dis moi si cette technique te semble correcte


\end{ocamldocdescription}




\label{val:Expr.freevarsb}\begin{ocamldoccode}
val freevarsb : VarsSet.t -> VarsSet.t -> bextexpr -> VarsSet.t
\end{ocamldoccode}
\index{freevarsb@\verb`freevarsb`}




\label{val:Expr.inquisition}\begin{ocamldoccode}
val inquisition : extexpr -> extexpr
\end{ocamldoccode}
\index{inquisition@\verb`inquisition`}
\begin{ocamldocdescription}
Détecte les portions de fouine pure, mais elle n'est pas utilisée car nous sommes en avancé en fait


\end{ocamldocdescription}




\label{val:Expr.inquisition-underscorebool}\begin{ocamldoccode}
val inquisition_bool : bextexpr -> bextexpr
\end{ocamldoccode}
\index{inquisition-underscorebool@\verb`inquisition_bool`}


\section{Module {\tt{Main}} : Intrepeter fouine}
\label{module:Main}\index{Main@\verb`Main`}




\ocamldocvspace{0.5cm}



\label{val:Main.parse-underscorestring}\begin{ocamldoccode}
val parse_string : string -> Expr.extexpr
\end{ocamldoccode}
\index{parse-underscorestring@\verb`parse_string`}
\begin{ocamldocdescription}
Parse une chaine de caractère à l'aide d'ocamlyacc


\end{ocamldocdescription}




\label{val:Main.initialize-underscoreenvir}\begin{ocamldoccode}
val initialize_envir : unit -> Env.value Env.Environnement.t
\end{ocamldoccode}
\index{initialize-underscoreenvir@\verb`initialize_envir`}
\begin{ocamldocdescription}
Initialise l'environnement au début de l'exécution de l'interpreter,
elle cela pourrait servir à l'implémentation d'un interpreter intéractif


\end{ocamldocdescription}




\label{val:Main.interpreter}\begin{ocamldoccode}
val interpreter : unit -> unit
\end{ocamldoccode}
\index{interpreter@\verb`interpreter`}
\begin{ocamldocdescription}
Fonction principale: c'est le main de notre programme


\end{ocamldocdescription}


\section{Module {\tt{Memfonc}} : Réécriture en fonctionnel pur : la mémoire est désormais un couple une fonction et le nombre d'image (ie le premier entier qui n'a pas encore image}
\label{module:Memfonc}\index{Memfonc@\verb`Memfonc`}




\ocamldocvspace{0.5cm}



\label{val:Memfonc.allocate}\begin{ocamldoccode}
val allocate : {\textquotesingle}a -> (int -> {\textquotesingle}a) * int -> int * ((int -> {\textquotesingle}a) * int)
\end{ocamldoccode}
\index{allocate@\verb`allocate`}




\label{val:Memfonc.read}\begin{ocamldoccode}
val read : {\textquotesingle}a -> ({\textquotesingle}a -> int) * {\textquotesingle}a -> int
\end{ocamldoccode}
\index{read@\verb`read`}




\label{val:Memfonc.modify}\begin{ocamldoccode}
val modify : ({\textquotesingle}a -> {\textquotesingle}b) * {\textquotesingle}a -> {\textquotesingle}a * {\textquotesingle}b -> ({\textquotesingle}a -> {\textquotesingle}b) * {\textquotesingle}a
\end{ocamldoccode}
\index{modify@\verb`modify`}


\section{Module {\tt{Memmachine}} : Gère la mémoire de la machine à pile}
\label{module:Memmachine}\index{Memmachine@\verb`Memmachine`}




\ocamldocvspace{0.5cm}



\begin{ocamldoccode}
{\tt{module }}{\tt{IntHash}}{\tt{ : }}\end{ocamldoccode}
\label{module:Memmachine.IntHash}\index{IntHash@\verb`IntHash`}

\begin{ocamldocsigend}


\label{type:Memmachine.IntHash.t}\begin{ocamldoccode}
type t = int 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{val:Memmachine.IntHash.equal}\begin{ocamldoccode}
val equal : {\textquotesingle}a -> {\textquotesingle}a -> bool
\end{ocamldoccode}
\index{equal@\verb`equal`}


\label{val:Memmachine.IntHash.hash}\begin{ocamldoccode}
val hash : int -> int
\end{ocamldoccode}
\index{hash@\verb`hash`}
\end{ocamldocsigend}






\begin{ocamldoccode}
{\tt{module }}{\tt{Mem}}{\tt{ : }}\end{ocamldoccode}
\label{module:Memmachine.Mem}\index{Mem@\verb`Mem`}

{\tt{Hashtbl.Make}}{\tt{(}}{\tt{IntHash}}{\tt{)}}





\label{type:Memmachine.memoire-underscoret}\begin{ocamldoccode}
type memoire_t = Composantmachine.memslot Mem.t 
\end{ocamldoccode}
\index{memoire-underscoret@\verb`memoire_t`}




\label{val:Memmachine.memoire}\begin{ocamldoccode}
val memoire : Composantmachine.memslot Mem.t
\end{ocamldoccode}
\index{memoire@\verb`memoire`}




\label{val:Memmachine.add-underscorememory}\begin{ocamldoccode}
val add_memory : Mem.key -> Composantmachine.memslot -> unit
\end{ocamldoccode}
\index{add-underscorememory@\verb`add_memory`}
\begin{ocamldocdescription}
fonction qui remplit une adresse


\end{ocamldocdescription}




\label{val:Memmachine.read-underscoreaddress}\begin{ocamldoccode}
val read_address : Mem.key -> Composantmachine.memslot
\end{ocamldoccode}
\index{read-underscoreaddress@\verb`read_address`}
\begin{ocamldocdescription}
fonction qui lit une référence


\end{ocamldocdescription}




\label{val:Memmachine.new-underscoreaddress}\begin{ocamldoccode}
val new_address : unit -> int
\end{ocamldoccode}
\index{new-underscoreaddress@\verb`new_address`}
\begin{ocamldocdescription}
Crée une nouvelle adresse mémoire


\end{ocamldocdescription}


\section{Module {\tt{Memory}} : fonctions de gestion de la mémoire pour les aspects impératifs}
\label{module:Memory}\index{Memory@\verb`Memory`}




\ocamldocvspace{0.5cm}



\begin{ocamldoccode}
{\tt{module }}{\tt{IntHash}}{\tt{ : }}\end{ocamldoccode}
\label{module:Memory.IntHash}\index{IntHash@\verb`IntHash`}

\begin{ocamldocsigend}


\label{type:Memory.IntHash.t}\begin{ocamldoccode}
type t = int 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{val:Memory.IntHash.equal}\begin{ocamldoccode}
val equal : {\textquotesingle}a -> {\textquotesingle}a -> bool
\end{ocamldoccode}
\index{equal@\verb`equal`}


\label{val:Memory.IntHash.hash}\begin{ocamldoccode}
val hash : int -> int
\end{ocamldoccode}
\index{hash@\verb`hash`}
\end{ocamldocsigend}






\begin{ocamldoccode}
{\tt{module }}{\tt{Mem}}{\tt{ : }}\end{ocamldoccode}
\label{module:Memory.Mem}\index{Mem@\verb`Mem`}

{\tt{Hashtbl.Make}}{\tt{(}}{\tt{IntHash}}{\tt{)}}





\label{type:Memory.memoire-underscoret}\begin{ocamldoccode}
type memoire_t = Env.value Mem.t 
\end{ocamldoccode}
\index{memoire-underscoret@\verb`memoire_t`}
\begin{ocamldocdescription}
définitions analogues aux environnements


\end{ocamldocdescription}




\label{val:Memory.memoire}\begin{ocamldoccode}
val memoire : Env.value Mem.t
\end{ocamldoccode}
\index{memoire@\verb`memoire`}




\label{val:Memory.add-underscorememory}\begin{ocamldoccode}
val add_memory : Mem.key -> Env.value -> unit
\end{ocamldoccode}
\index{add-underscorememory@\verb`add_memory`}
\begin{ocamldocdescription}
fonction qui remplit une adresse


\end{ocamldocdescription}




\label{val:Memory.read-underscoreaddress}\begin{ocamldoccode}
val read_address : Mem.key -> Env.value
\end{ocamldoccode}
\index{read-underscoreaddress@\verb`read_address`}
\begin{ocamldocdescription}
fonction qui lit une référence


\end{ocamldocdescription}




\label{val:Memory.new-underscoreaddress}\begin{ocamldoccode}
val new_address : unit -> int
\end{ocamldoccode}
\index{new-underscoreaddress@\verb`new_address`}
\begin{ocamldocdescription}
crée une nouvelle adresse


\end{ocamldocdescription}


\section{Module {\tt{Safe}} : Opérations sécurisées pour éviter les explosions de fouine}
\label{module:Safe}\index{Safe@\verb`Safe`}




\ocamldocvspace{0.5cm}



\label{val:Safe.safe-underscoreadd}\begin{ocamldoccode}
val safe_add : Env.value -> Env.value -> Env.value
\end{ocamldoccode}
\index{safe-underscoreadd@\verb`safe_add`}




\label{val:Safe.safe-underscoremult}\begin{ocamldoccode}
val safe_mult : Env.value -> Env.value -> Env.value
\end{ocamldoccode}
\index{safe-underscoremult@\verb`safe_mult`}




\label{val:Safe.safe-underscoresou}\begin{ocamldoccode}
val safe_sou : Env.value -> Env.value -> Env.value
\end{ocamldoccode}
\index{safe-underscoresou@\verb`safe_sou`}




\label{val:Safe.safe-underscorediv}\begin{ocamldoccode}
val safe_div : Env.value -> Env.value -> Env.value
\end{ocamldoccode}
\index{safe-underscorediv@\verb`safe_div`}




\label{val:Safe.safe-underscoreop}\begin{ocamldoccode}
val safe_op : Env.value -> (int -> int -> bool) -> Env.value -> Env.value
\end{ocamldoccode}
\index{safe-underscoreop@\verb`safe_op`}


\section{Module {\tt{Showmachine}} : Gère l'affichage des éléments de la machine à pile}
\label{module:Showmachine}\index{Showmachine@\verb`Showmachine`}




\ocamldocvspace{0.5cm}



\label{val:Showmachine.tab}\begin{ocamldoccode}
val tab : int -> string
\end{ocamldoccode}
\index{tab@\verb`tab`}




\label{val:Showmachine.join}\begin{ocamldoccode}
val join : string -> string list -> string
\end{ocamldoccode}
\index{join@\verb`join`}
\begin{ocamldocdescription}
Semblable à la fonction python: met bout à bout des éléments d'une liste en les séparant par un séparateur


\end{ocamldocdescription}




\label{val:Showmachine.affiche-underscoreuplet}\begin{ocamldoccode}
val affiche_uplet : Composantmachine.memslot list -> unit
\end{ocamldoccode}
\index{affiche-underscoreuplet@\verb`affiche_uplet`}
\begin{ocamldocdescription}
Affiche un n-uplet avec les commandes de la machine à pile


\end{ocamldocdescription}




\label{val:Showmachine.affiche-underscoreslot}\begin{ocamldoccode}
val affiche_slot : Composantmachine.memslot -> unit
\end{ocamldoccode}
\index{affiche-underscoreslot@\verb`affiche_slot`}
\begin{ocamldocdescription}
Affiche une case mémoire de la machine à pile


\end{ocamldocdescription}




\label{val:Showmachine.affiche-underscoreenv}\begin{ocamldoccode}
val affiche_env : (string * {\textquotesingle}a) list -> unit
\end{ocamldoccode}
\index{affiche-underscoreenv@\verb`affiche_env`}
\begin{ocamldocdescription}
Affiche l'environnement complet


\end{ocamldocdescription}




\label{val:Showmachine.affiche-underscorepile}\begin{ocamldoccode}
val affiche_pile : Composantmachine.memslot list -> unit
\end{ocamldoccode}
\index{affiche-underscorepile@\verb`affiche_pile`}




\label{val:Showmachine.joli-underscorecode}\begin{ocamldoccode}
val joli_code : int -> Composantmachine.instruction list -> string -> string
\end{ocamldoccode}
\index{joli-underscorecode@\verb`joli_code`}
\begin{ocamldocdescription}
Fournit un code lisible par un humain


\end{ocamldocdescription}




\label{val:Showmachine.joli-underscorecouple}\begin{ocamldoccode}
val joli_couple :
  int -> Composantmachine.instruction list list -> string -> string
\end{ocamldoccode}
\index{joli-underscorecouple@\verb`joli_couple`}




\label{val:Showmachine.affiche-underscorecode}\begin{ocamldoccode}
val affiche_code : Composantmachine.instruction list -> unit
\end{ocamldoccode}
\index{affiche-underscorecode@\verb`affiche_code`}
\begin{ocamldocdescription}
Affiche le code lisible associé à l'expression


\end{ocamldocdescription}


\section{Module {\tt{Tradcont}} : Transformations de programmes: élimine les exceptions}
\label{module:Tradcont}\index{Tradcont@\verb`Tradcont`}




\ocamldocvspace{0.5cm}



\label{val:Tradcont.nbk}\begin{ocamldoccode}
val nbk : int Pervasives.ref
\end{ocamldoccode}
\index{nbk@\verb`nbk`}




\label{val:Tradcont.nbkE}\begin{ocamldoccode}
val nbkE : int Pervasives.ref
\end{ocamldoccode}
\index{nbkE@\verb`nbkE`}




\label{val:Tradcont.nbva}\begin{ocamldoccode}
val nbva : int Pervasives.ref
\end{ocamldoccode}
\index{nbva@\verb`nbva`}




\label{val:Tradcont.newk}\begin{ocamldoccode}
val newk : unit -> int * Expr.expr
\end{ocamldoccode}
\index{newk@\verb`newk`}
\begin{ocamldocdescription}
Crée une nouvelle variable de continuation


\end{ocamldocdescription}




\label{val:Tradcont.newkE}\begin{ocamldoccode}
val newkE : unit -> int * Expr.expr
\end{ocamldoccode}
\index{newkE@\verb`newkE`}
\begin{ocamldocdescription}
Crée une nouvelle variable de continuation exceptionnelle


\end{ocamldocdescription}




\label{val:Tradcont.newva}\begin{ocamldoccode}
val newva : unit -> int * Expr.expr
\end{ocamldoccode}
\index{newva@\verb`newva`}
\begin{ocamldocdescription}
Crée une nouvelle variable correspondant à une valeur


\end{ocamldocdescription}




\label{val:Tradcont.cont-underscoreexpr}\begin{ocamldoccode}
val cont_expr : Expr.extexpr -> Expr.extexpr
\end{ocamldoccode}
\index{cont-underscoreexpr@\verb`cont_expr`}
\begin{ocamldocdescription}
Effectue la traduction en continuation en éliminant les exceptions


\end{ocamldocdescription}




\label{val:Tradcont.exec-underscoreexcep}\begin{ocamldoccode}
val exec_excep : Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{exec-underscoreexcep@\verb`exec_excep`}


\section{Module {\tt{Tradimp}} : Transformations de programme: élimination de l'impératif}
\label{module:Tradimp}\index{Tradimp@\verb`Tradimp`}




\ocamldocvspace{0.5cm}



\label{val:Tradimp.nbv}\begin{ocamldoccode}
val nbv : int Pervasives.ref
\end{ocamldoccode}
\index{nbv@\verb`nbv`}




\label{val:Tradimp.nbs}\begin{ocamldoccode}
val nbs : int Pervasives.ref
\end{ocamldoccode}
\index{nbs@\verb`nbs`}




\label{val:Tradimp.news}\begin{ocamldoccode}
val news : unit -> int * Expr.expr
\end{ocamldoccode}
\index{news@\verb`news`}
\begin{ocamldocdescription}
fonction qui renvoie un sn où n est un numéro par encore utilisé, où sn
est une variable correspondant à l'environnement


\end{ocamldocdescription}




\label{val:Tradimp.newv}\begin{ocamldoccode}
val newv : unit -> int * Expr.expr
\end{ocamldoccode}
\index{newv@\verb`newv`}
\begin{ocamldocdescription}
Crée une nouvelle variable correspondant à une valeur


\end{ocamldocdescription}




\label{val:Tradimp.trad-underscoreexpr}\begin{ocamldoccode}
val trad_expr : Expr.extexpr -> Expr.extexpr
\end{ocamldoccode}
\index{trad-underscoreexpr@\verb`trad_expr`}
\begin{ocamldocdescription}
Effectue la transformation de programme éliminant les aspects impératifs


\end{ocamldocdescription}




\label{val:Tradimp.exec-underscoretrad}\begin{ocamldoccode}
val exec_trad : Expr.extexpr -> int * Expr.expr
\end{ocamldoccode}
\index{exec-underscoretrad@\verb`exec_trad`}


\section{Module {\tt{Tradmachine}} : Ce module implémente la machine à pile ainsi que le compilateur fouine vers
stackcode}
\label{module:Tradmachine}\index{Tradmachine@\verb`Tradmachine`}




\ocamldocvspace{0.5cm}



\label{val:Tradmachine.endcouple}\begin{ocamldoccode}
val endcouple : {\textquotesingle}a list -> Composantmachine.instruction list
\end{ocamldoccode}
\index{endcouple@\verb`endcouple`}
\begin{ocamldocdescription}
Complète la compilation des couples par les endlet nécessaires


\end{ocamldocdescription}




\label{val:Tradmachine.compile}\begin{ocamldoccode}
val compile : Expr.extexpr -> Composantmachine.instruction list
\end{ocamldoccode}
\index{compile@\verb`compile`}
\begin{ocamldocdescription}
Compile le code fouine en stackcode


\end{ocamldocdescription}




\label{val:Tradmachine.compileb}\begin{ocamldoccode}
val compileb : Expr.bextexpr -> Composantmachine.instruction list
\end{ocamldoccode}
\index{compileb@\verb`compileb`}
\begin{ocamldocdescription}
Compile les booléens en stackcode


\end{ocamldocdescription}




\label{val:Tradmachine.val-underscoreenv}\begin{ocamldoccode}
val val_env : ({\textquotesingle}a * {\textquotesingle}b) list -> {\textquotesingle}a -> {\textquotesingle}b
\end{ocamldoccode}
\index{val-underscoreenv@\verb`val_env`}
\begin{ocamldocdescription}
Accède à la valeur associée à la clef x dans l'environnement


\end{ocamldocdescription}




\label{val:Tradmachine.exec-underscorecode}\begin{ocamldoccode}
val exec_code :
  Composantmachine.instruction list ->
  Composantmachine.environnement -> Composantmachine.memslot list -> unit
\end{ocamldoccode}
\index{exec-underscorecode@\verb`exec_code`}
\begin{ocamldocdescription}
Exécute un code écrit en stackcode avec la machine à pile


\end{ocamldocdescription}




\label{val:Tradmachine.execution}\begin{ocamldoccode}
val execution : Composantmachine.instruction list -> unit
\end{ocamldoccode}
\index{execution@\verb`execution`}


\section{Module {\tt{Typechecking}} : Module gérant l'inférence de type de notre interpreter}
\label{module:Typechecking}\index{Typechecking@\verb`Typechecking`}




\ocamldocvspace{0.5cm}



\label{val:Typechecking.free-underscoretype-underscorecounter}\begin{ocamldoccode}
val free_type_counter : int Pervasives.ref
\end{ocamldoccode}
\index{free-underscoretype-underscorecounter@\verb`free_type_counter`}




\label{val:Typechecking.intToLetter}\begin{ocamldoccode}
val intToLetter : int -> string
\end{ocamldoccode}
\index{intToLetter@\verb`intToLetter`}
\begin{ocamldocdescription}
Renvoie la lettre associée à un entier entre 0 et 25


\end{ocamldocdescription}




\label{val:Typechecking.int-underscoreto-underscoreletters}\begin{ocamldoccode}
val int_to_letters : int -> string
\end{ocamldoccode}
\index{int-underscoreto-underscoreletters@\verb`int_to_letters`}
\begin{ocamldocdescription}
Renvoie le polymorphisme voulu pour un entier donne ie 0 renvoie a'


\end{ocamldocdescription}




\label{val:Typechecking.new-underscorefree-underscoretype}\begin{ocamldoccode}
val new_free_type : unit -> string
\end{ocamldoccode}
\index{new-underscorefree-underscoretype@\verb`new_free_type`}
\begin{ocamldocdescription}
Construit un nouveau type polymorphique libre


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{EnvType}}{\tt{ : }}\end{ocamldoccode}
\label{module:Typechecking.EnvType}\index{EnvType@\verb`EnvType`}

{\tt{Map.Make}}{\tt{(}}{\tt{String}}{\tt{)}}

\begin{ocamldocdescription}
Module utilisé pour stocker l'envi des types


\end{ocamldocdescription}




\label{type:Typechecking.f-underscoretype}\begin{ocamldoccode}
type f_type =
  | Int_f
  | List_f of f_type
\end{ocamldoccode}
\begin{ocamldoccomment}
On stocke le type d'élément stockés dans la liste


\end{ocamldoccomment}
\begin{ocamldoccode}
  | Fun_f of f_type * f_type
\end{ocamldoccode}
\begin{ocamldoccomment}
Une fonction fouine, de type truc donne bidule


\end{ocamldoccomment}
\begin{ocamldoccode}
  | Cart_f of f_type list
\end{ocamldoccode}
\begin{ocamldoccomment}
Un produit cart c'est une liste de type


\end{ocamldoccomment}
\begin{ocamldoccode}
  | UserType of string
\end{ocamldoccode}
\begin{ocamldoccomment}
Nom du type somme défini par le programmeur


\end{ocamldoccomment}
\begin{ocamldoccode}
  | TypeOf of string
\end{ocamldoccode}
\begin{ocamldoccomment}
Pour stocker des trucs par encore typés


\end{ocamldoccomment}
\begin{ocamldoccode}
  | Ref_f of f_type
\end{ocamldoccode}
\begin{ocamldoccomment}
Si on est une ref on connait le type du truc pointé


\end{ocamldoccomment}
\begin{ocamldoccode}
  | Unit_f
\end{ocamldoccode}
\index{f-underscoretype@\verb`f_type`}




\label{type:Typechecking.env-underscoretype-underscoret}\begin{ocamldoccode}
type env_type_t = f_type EnvType.t 
\end{ocamldoccode}
\index{env-underscoretype-underscoret@\verb`env_type_t`}




\label{val:Typechecking.string-underscoreof-underscoreftype}\begin{ocamldoccode}
val string_of_ftype : f_type EnvType.t -> f_type -> string
\end{ocamldoccode}
\index{string-underscoreof-underscoreftype@\verb`string_of_ftype`}
\begin{ocamldocdescription}
Convertit un objet type en une chaîne lisible


\end{ocamldocdescription}




\label{val:Typechecking.print-underscoreenvtype}\begin{ocamldoccode}
val print_envtype : f_type EnvType.t ->
  string -> f_type -> unit
\end{ocamldoccode}
\index{print-underscoreenvtype@\verb`print_envtype`}
\begin{ocamldocdescription}
Affiche l'environnement complet


\end{ocamldocdescription}




\label{type:Typechecking.type-underscorelist-underscoret}\begin{ocamldoccode}
type type_list_t = f_type EnvType.t 
\end{ocamldoccode}
\index{type-underscorelist-underscoret@\verb`type_list_t`}
\begin{ocamldocdescription}
On stocke les types définis par l'utilisateur


\end{ocamldocdescription}




\label{val:Typechecking.getvartype}\begin{ocamldoccode}
val getvartype : f_type EnvType.t Pervasives.ref ->
  EnvType.key -> f_type
\end{ocamldoccode}
\index{getvartype@\verb`getvartype`}
\begin{ocamldocdescription}
Utilitaire pour lire les types dans l'environnement


\end{ocamldocdescription}




\label{val:Typechecking.parent-underscoret}\begin{ocamldoccode}
val parent_t : f_type EnvType.t Pervasives.ref ->
  EnvType.key -> f_type
\end{ocamldoccode}
\index{parent-underscoret@\verb`parent_t`}
\begin{ocamldocdescription}
Le find de l'union find


\end{ocamldocdescription}




\label{val:Typechecking.updatevar}\begin{ocamldoccode}
val updatevar : {\textquotesingle}a EnvType.t Pervasives.ref ->
  EnvType.key -> {\textquotesingle}a -> unit
\end{ocamldoccode}
\index{updatevar@\verb`updatevar`}
\begin{ocamldocdescription}
Utilitaire pour mettre à jour le type d'une variable, utilisée dans l'union
de l'union find


\end{ocamldocdescription}




\label{val:Typechecking.save-underscorevars}\begin{ocamldoccode}
val save_vars :
  Expr.extexpr ->
  {\textquotesingle}a EnvType.t Pervasives.ref ->
  (EnvType.key * {\textquotesingle}a) list
\end{ocamldoccode}
\index{save-underscorevars@\verb`save_vars`}
\begin{ocamldocdescription}
Récupère les types des variables pour les sauvergarder lorsqu'on les écrase


\end{ocamldocdescription}




\label{val:Typechecking.setback-underscorevars}\begin{ocamldoccode}
val setback_vars :
  {\textquotesingle}a EnvType.t Pervasives.ref ->
  (EnvType.key * {\textquotesingle}a) list -> unit
\end{ocamldoccode}
\index{setback-underscorevars@\verb`setback_vars`}
\begin{ocamldocdescription}
Remet les variables sauvegardées


\end{ocamldocdescription}




\label{val:Typechecking.type-underscorearg}\begin{ocamldoccode}
val type_arg : f_type EnvType.t Pervasives.ref ->
  f_type -> f_type
\end{ocamldoccode}
\index{type-underscorearg@\verb`type_arg`}
\begin{ocamldocdescription}
Affecte leur type aux arguments d'une fonction lors d'une application, pour
déterminer le type de retoure de la fonction


\end{ocamldocdescription}




\label{val:Typechecking.t-underscoreunify}\begin{ocamldoccode}
val t_unify :
  f_type ->
  f_type ->
  env_type_t Pervasives.ref ->
  type_list_t -> f_type
\end{ocamldoccode}
\index{t-underscoreunify@\verb`t_unify`}
\begin{ocamldocdescription}
Décide si deux trucs peuvent avoir même type, et si oui renvoie le type
convenant aux deux trucs, sinon explose


\end{ocamldocdescription}




\label{val:Typechecking.infer}\begin{ocamldoccode}
val infer :
  Expr.extexpr ->
  env_type_t ->
  type_list_t -> f_type * env_type_t
\end{ocamldoccode}
\index{infer@\verb`infer`}
\begin{ocamldocdescription}
Fonction principale de l'inférence de type: elle renvoie le type de l'expression
ainsi que les affectations de type à toutes les variables


\end{ocamldocdescription}


\end{document}
